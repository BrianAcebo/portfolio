portfolio_projects = [
    {
        "id": 1,
        "title": "Paperboat CRM",
        "overview": "Paperboat CRM is an AI sales assistant that uses GPT-4o-mini for LLM, DeepGram for TTS, and Cartesia for STT to build an robust AI voice dialer to help sales teams automate their outreach and qualify leads.",
        "description": "Paperboat CRM is an AI sales assistant that uses GPT-4o-mini for LLM, DeepGram for TTS, and Cartesia for STT to build an robust AI voice dialer that can cold call and collect data to help sales teams automate their outreach and qualify leads. It also provides AI sales intelligence that uses GPT-4o-mini for LLM to analyze conversations and provide insights, as well as organization analytics and coaching.",
        "image": "https://images.unsplash.com/photo-1531156992292-d36397ee9184?q=80&w=2670&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        "category_id": 1,
        "link": "https://paperboatcrm.com",
        "project_type": "work",
        "featured": True,
        "progress": 0.5,
        "tags": ["AI", "Artificial Intelligence", "Sales", "CRM", "Automation"],
        "current_episode": "S1:E1",
        "tech_stack": ["React", "Tailwind CSS", "TypeScript", "PostgreSQL", "Supabase", "Python", "OpenAI", "DeepGram", "Cartesia"],
        "key_features": [
            "AI voice dialer that cold calls and qualifies leads using DeepGram for TTS, GPT-4o-mini for LLM, and Cartesia for STT",
            "AI sales intelligence that uses GPT-4o-mini for LLM to analyze conversations and provide insights",
            "AI sales intelligence also provides organization analytics and coaching",
            "A/B testing and campaigns for lead segmentation and targeting",
            "Fully customizable playbooks for script guidance for the AI voice dialer"
        ]
    },
    {
        "id": 2,
        "title": "True Sight Intel",
        "overview": "True Sight Intel is an AI-powered OSINT assistant for cyber investigations to map identities, visualize OSINT graphs, and track threats in real-time. It uses OpenAI's GPT-4o-mini for LLM to perform OSINT research and analysis, and visualize OSINT data in a graph format for representation of nodes and edge relationships.",
        "description": "True Sight Intel is an AI-powered OSINT assistant for cyber investigations to map identities, visualize OSINT graphs, and track threats in real-time. It uses OpenAI's GPT-4o-mini for LLM to perform OSINT research and analysis, and visualize OSINT data in a graph format for representation of nodes and edge relationships.",
        "image": "https://images.unsplash.com/photo-1481887328591-3e277f9473dc?q=80&w=2362&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        "category_id": 1,
        "link": "https://truesightintel.com",
        "project_type": "work",
        "featured": True,
        "progress": 0.9,
        "tags": ["AI", "Artificial Intelligence", "OSINT", "Cybersecurity"],
        "current_episode": "S3:E2",
        "tech_stack": ["React", "Tailwind CSS", "TypeScript", "PostgreSQL", "Supabase", "OpenAI"],
        "key_features": [
            "AI-powered OSINT assistant for cyber investigations to map digital footprints",
            "Uses OpenAI's GPT-4o-mini for LLM to perform OSINT research and analysis",
            "Visualizes OSINT data in a graph format for representation of nodes and edge relationships",
            "Perform single thread actions to find related entities using third-party APIs and services",
        ]
    },
    {
        "id": 3,
        "title": "Nascent",
        "overview": "Nascent is a crypto-native investment and trading firm that builds, invests in, and operates across decentralized finance, digital assets, and open financial markets. My role consisted of working on an internal, web-based trading and analytics platform used by professional traders to monitor markets, analyze data, and execute trades in real time.",
        "description": "Nascent is a crypto-native investment and trading firm that builds, invests in, and operates across decentralized finance, digital assets, and open financial markets. My role consisted of working on an internal, web-based trading and analytics platform used by professional traders to monitor markets, analyze data, and execute trades in real time.",
        "image": "https://images.unsplash.com/photo-1563986768711-b3bde3dc821e?q=80&w=2336&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        "category_id": 2,
        "link": "https://nascent.xyz",
        "project_type": "work",
        "featured": True,
        "progress": 0.8,
        "tags": ["Crypto", "Trading", "Investing", "DeFi", "Blockchain", "Finance", "FinTech"],
        "current_episode": "S6:E3",
        "tech_stack": ["React", "Tailwind CSS", "TypeScript", "Rust", "AWS", "PostgreSQL"],
        "key_features": [
            "Web-based trading and analytics platform used by professional traders to monitor markets, analyze data, and execute trades",
            "High-performance user interfaces for financial data, ensuring reliability under heavy load, and optimizing real-time updates for speed and accuracy",
            "Worked exclusively on the trade execution engine that handles the core trading logic and data processing",
            "Collaborated closely with traders and backend engineers to refine product usability and functionality",
        ]
    },
    {
        "id": 4,
        "title": "Pocket",
        "overview": "Pocket is a secure online platform for buying, selling, transferring, and storing cryptocurrency. This was a take home test for a job application for Nascent to showcase my skills by building a modern, responsive, and user-friendly trading interface.",
        "description": "Pocket is a secure online platform for buying, selling, transferring, and storing cryptocurrency. This was a take home test for a job application for Nascent to showcase my skills by building a modern, responsive, and user-friendly trading interface.",
        "image": "https://images.unsplash.com/photo-1634704784915-aacf363b021f?q=80&w=2340&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        "category_id": 2,
        "link": "https://nascent-frontend-test.vercel.app/",
        "github_link": "https://github.com/BrianAcebo/nascent-frontend-test",
        "project_type": "personal",
        "featured": False,
        "progress": 0.3,
        "tags": ["Crypto", "Trading", "Investing", "DeFi", "Blockchain", "Finance", "FinTech"],
        "current_episode": "S1:E4",
        "tech_stack": ["React", "Tailwind CSS", "TypeScript"],
        "key_features": [
            "Modern, responsive, and user-friendly trading interface",
            "Visualize market data and connect to third-party APIs to get real-time market data",
            "React testing library for testing",
        ]
    },
    {
        "id": 5,
        "title": "Cozy Earth",
        "overview": "Cozy Earth is a premium apparel and lifestyle brand known for its luxury bedding and loungewear. Their storefront was a single page application built with Vue.js and Tailwind CSS, with Shopify as the backend for product management and inventory. As a rapidly growing DTC company, they required a performant, scalable frontend system capable of supporting high-volume marketing campaigns and seamless customer experiences.",
        "description": "Cozy Earth is a premium apparel and lifestyle brand known for its luxury bedding and loungewear. Their storefront was a single page application built with Vue.js and Tailwind CSS, with Shopify as the backend for product management and inventory. As a rapidly growing DTC company, they required a performant, scalable frontend system capable of supporting high-volume marketing campaigns and seamless customer experiences.",
        "image": "https://images.unsplash.com/photo-1698746044370-4ea50c59c009?q=80&w=987&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        "category_id": 5,
        "link": "https://cozyearth.com/",
        "project_type": "work",
        "featured": False,
        "progress": 0.7,
        "tags": ["E-commerce", "Luxury", "Apparel"],
        "current_episode": "S2:E5",
        "tech_stack": ["Vue.js", "Tailwind CSS", "Shopify"],
        "key_features": [
            "Performant, scalable frontend system capable of supporting high-volume marketing campaigns and seamless customer experiences",
            "Built and maintained high-converting landing pages for major seasonal campaigns, focusing on speed, responsiveness, and mobile-first UX",
            "Embedded within a cross-functional team, responsible for delivering high-impact features",
            "Created React/JSX-based custom interfaces within the Shopify Admin for richer internal content configuration and improved merchant workflows",
            "Diagnosed render bottlenecks and implemented strategies to reduce JavaScript payload size, improving site performance across key mobile metrics"
        ]
    },
    {
        "id": 6,
        "title": "Fount Society",
        "overview": "Fount Society is a clean skincare brand under the Cozy Earth umbrella, focused on health-first, ingredient-conscious formulations. Their storefront was a single page application built with SvelteKit and Tailwind CSS, with headless Shopify as the backend for product management and inventory. As a subsidiary of Cozy Earth, they required a performant, scalable frontend system capable of supporting high-volume marketing campaigns and seamless customer experiences. I was the tech lead for the project and responsible for all technical direction and architecture.",
        "description": "Fount Society is a clean skincare brand under the Cozy Earth umbrella, focused on health-first, ingredient-conscious formulations. Their storefront was a single page application built with SvelteKit and Tailwind CSS, with headless Shopify as the backend for product management and inventory. As a subsidiary of Cozy Earth, they required a performant, scalable frontend system capable of supporting high-volume marketing campaigns and seamless customer experiences. I was the tech lead for the project and responsible for all technical direction and architecture.",
        "image": "https://images.unsplash.com/photo-1585945037805-5fd82c2e60b1?q=80&w=1446&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        "category_id": 5,
        "link": "https://fountsociety.com/",
        "project_type": "work",
        "featured": False,
        "progress": 0.4,
        "tags": ["E-commerce", "Luxury", "Skincare"],
        "current_episode": "S1:E6",
        "tech_stack": ["SvelteKit", "Tailwind CSS", "Shopify", "Headless Shopify"],
        "key_features": [
            "Performant, scalable frontend system capable of supporting high-volume marketing campaigns and seamless customer experiences",
            "Built and maintained high-converting landing pages for major seasonal campaigns, focusing on speed, responsiveness, and mobile-first UX",
            "Embedded within a cross-functional team, responsible for delivering high-impact features",
            "Created React/JSX-based custom interfaces within the Shopify Admin for richer internal content configuration and improved merchant workflows",
            "Diagnosed render bottlenecks and implemented strategies to reduce JavaScript payload size, improving site performance across key mobile metrics"
        ]
    },
    {
        "id": 7,
        "title": "Compose",
        "overview": "Compose is an A/B testing software that helps merchants create and manage A/B tests for conversion rate optimization. I contributed directly to the core product, building intuitive interfaces and reusable components that empowered users to experiment, optimize, and deploy changes with confidence.",
        "description": "Compose is an A/B testing software that helps merchants create and manage A/B tests for conversion rate optimization. I contributed directly to the core product, building intuitive interfaces and reusable components that empowered users to experiment, optimize, and deploy changes with confidence.",
        "image": "https://images.unsplash.com/photo-1553877522-43269d4ea984?q=80&w=2340&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        "category_id": 3,
        "link": "https://compose.co/",
        "project_type": "work",
        "featured": True,
        "progress": 0.6,
        "tags": ["A/B Testing", "Conversion Rate Optimization", "Shopify"],
        "current_episode": "S4:E7",
        "tech_stack": ["React", "Tailwind CSS", "TypeScript"],
        "key_features": [
            "Built key features of the app using React and Vue, including experiment creation flows, test variant management, and real-time performance dashboards",
            "Developed a dynamic component builder that allowed users to visually assemble and preview test variants before publishing",
            "Worked closely with product and design to translate feature specs into seamless, performant UI",
            "Integrated with a MongoDB backend to manage experiment data, user sessions, and content versioning",
            "Collaborated on testing strategies and CI workflows to maintain quality and ship new features rapidly"
        ]
    },
    {
        "id": 8,
        "title": "Jot Party",
        "overview": "Jot Party is a modern content management app designed for Shopify merchants to create and manage blog articles, landing pages, and reusable content structures — all from a streamlined web-based interface, without relying on a third-party CMS.",
        "description": "Jot Party is a modern content management app designed for Shopify merchants to create and manage blog articles, landing pages, and reusable content structures — all from a streamlined web-based interface, without relying on a third-party CMS.",
        "image": "https://images.unsplash.com/photo-1674027392842-29f8354e236c?q=80&w=2532&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        "category_id": 6,
        "link": "https://jotparty.com/",
        "github_link": "https://github.com/BrianAcebo/jotparty",
        "project_type": "personal",
        "featured": False,
        "progress": 0.2,
        "tags": ["Content Management", "Shopify", "Blog"],
        "current_episode": "S5:E8",
        "tech_stack": ["SvelteKit", "Tailwind CSS", "TypeScript", "Shopify App"],
        "key_features": [
            "Shopify App Authentication: Automatically generates secure admin tokens after app install via the Shopify Admin API",
            "Visual Blog & Landing Page Editor: Structured UI for building rich content layouts, organized by blog or category.",
            "Metaobject Management: Enables merchants to create and reuse structured content blocks via Shopify's native metafield system.",
            "Real-Time Article Sync: Articles are created, edited, and published directly to the store, fully synced with Shopify’s blog infrastructure."
        ]
    },
    {
        "id": 9,
        "title": "Classico Ride Share",
        "overview": "Classico is a polished marketing site and early access funnel for a luxury ride-share concept that lets users book classic cars for events, built with Next.js and Tailwind CSS.",
        "description": "Classico is a polished marketing site and early access funnel for a luxury ride-share concept that lets users book classic cars for events,",
        "image": "https://www.ridewithclassico.com/static/media/hero.42d10e1980c4ee461f1c.jpg",
        "category_id": 8,
        "link": "https://www.ridewithclassico.com/",
        "github_link": "https://github.com/classico",
        "project_type": "work",
        "featured": False,
        "progress": 0.1,
        "tags": ["Marketing", "Ride-sharing", "Luxury"],
        "current_episode": "S7:E9",
        "tech_stack": ["React", "Vite"],
        "key_features": [
            "Curated Vehicle Showcase: Scrollable gallery of high-end classic cars, optimized for desktop and mobile viewing",
            "Value Proposition Design: Landing page structured around clear messaging, visual hierarchy, and brand identity",
            "Waitlist Onboarding Flow: Simple sign-up form for early access with clear user feedback",
            "Performance-Tuned Architecture: Built with React and powered by Vite to ensure fast load times and lightweight build output.",
        ]
    },
    {
        "id": 10,
        "title": "Project Atlas",
        "overview": "Project Atlas is a visual content strategy tool built for SEO professionals and content teams to create interactive topic clusters, assign article ideas, and map internal linking strategies",
        "description": "Project Atlas is a visual content strategy tool built for SEO professionals and content teams to create interactive topic clusters, assign article ideas, and map internal linking strategies",
        "image": "https://images.unsplash.com/photo-1674027326254-88c960d8e561?q=80&w=2532&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        "category_id": 7,
        "link": "https://project-atlas-weld.vercel.app/",
        "github_link": "https://github.com/BrianAcebo/project-atlas",
        "project_type": "personal",
        "featured": False,
        "progress": 0.3,
        "tags": ["SEO", "Content Strategy", "Topic Clusters"],
        "current_episode": "S2:E10",
        "tech_stack": ["React", "Tailwind CSS", "TypeScript"],
        "key_features": [
            "Interactive Topic Cluster Builder: Drag-and-drop interface for creating, organizing, and visualizing topic clusters",
            "Article Idea Generator: AI-powered tool that suggests article topics based on user input and keyword research",
            "Internal Link Mapping: Visual tool for mapping out internal linking strategies between articles",
            "Performance-Optimized Architecture: Built with React and powered by Vite to ensure fast load times and lightweight build output.",
        ]
    },
    {
        "id": 11,
        "title": "Spotify Clone",
        "overview": "Spotify clone is a modern audio streaming interface inspired by Spotify's core playback experience. Built as a take-home project to demonstrate frontend engineering skill, product intuition, and interaction design",
        "description": "Spotify clone is a modern audio streaming interface inspired by Spotify's core playback experience. Built as a take-home project to demonstrate frontend engineering skill, product intuition, and interaction design",
        "image": "https://images.unsplash.com/photo-1643208589896-07b8feb4dffa?q=80&w=2338&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        "category_id": 4,
        "link": "https://spotify-clone-one-snowy.vercel.app/",
        "github_link": "https://github.com/BrianAcebo/spotify-clone",
        "project_type": "personal",
        "featured": True,
        "progress": 0.7,
        "tags": ["Music", "Streaming", "Spotify"],
        "current_episode": "S3:E11",
        "tech_stack": ["React", "Tailwind CSS", "TypeScript"],
        "key_features": [
            "Modern audio streaming interface inspired by Spotify's core playback experience",
            "Built with React and powered by Vite to ensure fast load times and lightweight build output",
            "Uses React for state management and routing",
            "Uses Tailwind CSS for styling",
        ]
    },
    {
        "id": 12,
        "title": "Pokedex",
        "overview": "Pokedex is a one of the first projects I ever built. It uses the PokeAPI to allow users to search for Pokemon and view their details.",
        "description": "Pokedex is a one of the first projects I ever built. It uses the PokeAPI to allow users to search for Pokemon and view their details.",
        "image": "https://images.unsplash.com/photo-1605979257913-1704eb7b6246?q=80&w=2340&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        "category_id": 8,
        "link": "https://brians-pokedex.vercel.app/",
        "github_link": "https://github.com/BrianAcebo/Brians-Pokedex",
        "project_type": "personal",
        "featured": False,
        "progress": 0.2,
        "tags": ["Pokemon", "Pokedex", "API"],
        "current_episode": "S4:E12",
        "tech_stack": ["SvelteKit"],
        "key_features": [
            "One of the first projects I ever built",
            "Uses the PokeAPI to allow users to search for Pokemon and view their details",
            "Uses React for state management and routing",
            "Uses Tailwind CSS for styling",
        ]
    },
]


categories = [
    {
        "id": 1,
        "name": "Artificial Intelligence",
    },
    {
        "id": 2,
        "name": "Crypto & Trading",
    },
    {
        "id": 3,
        "name": "A/B Testing",
    },
    {
        "id": 4,
        "name": "Music",
    },
    {
        "id": 5,
        "name": "E-commerce",
    },
    {
        "id": 6,
        "name": "Shopify Apps",
    },
    {
        "id": 7,
        "name": "Search Engine Optimization",
    },
     {
        "id": 8,
        "name": "General",
    },
]

blog_posts = [
    {
        "id": 1,
        "slug": "building-ai-voice-dialers-with-gpt-and-deepgram",
        "title": "Building AI Voice Dialers with GPT-4 and DeepGram",
        "excerpt": "A deep dive into combining LLMs with real-time voice to automate outbound sales calls while keeping conversations natural and effective.",
        "body": """## The problem with traditional cold calling

Cold calling is time-consuming and often feels robotic. Sales teams spend hours dialing and reading scripts, while prospects tune out after the first sentence.

## Why we chose GPT-4 and DeepGram

We needed an LLM that could handle open-ended conversation and a voice stack that could stream audio with low latency. **GPT-4** gave us the reasoning; **DeepGram** gave us fast, accurate speech-to-text and text-to-speech.

## Architecture overview

1. **Inbound audio** → DeepGram STT → transcript
2. **Transcript** → GPT-4 (with system prompt + conversation history) → next reply
3. **Reply text** → DeepGram TTS → outbound audio

We run this in a loop with sub-second latency so the prospect never feels a long pause.

## Lessons learned

- **Prompt design matters.** We spent weeks tuning the system prompt so the AI stays on-message without sounding scripted.
- **Fallbacks are critical.** When the LLM hesitates or the stream drops, we fall back to predefined phrases so the call never goes silent.
- **Human-in-the-loop.** We flag low-confidence moments and offer the rep a one-click takeover.

If you're exploring AI voice for sales or support, I'd start with a narrow use case (e.g., appointment confirmation) before going full cold-call.""",
        "image": "https://images.unsplash.com/photo-1677442136019-21780ecad995?q=80&w=2532&auto=format&fit=crop",
        "author": "Brian Acebo",
        "author_avatar": "",
        "published_at": "2025-01-15T14:00:00Z",
        "reading_time_minutes": 8,
        "tags": ["AI", "Voice", "Sales", "GPT-4", "DeepGram"],
        "featured": True,
        "category_id": 1,
    },
    {
        "id": 2,
        "slug": "osint-and-llms-cyber-investigations",
        "title": "OSINT and LLMs for Cyber Investigations",
        "excerpt": "Using large language models to structure and analyze open-source intelligence for threat mapping and identity resolution.",
        "body": """## The OSINT bottleneck

Investigators collect huge amounts of open-source data—social profiles, domains, breach dumps, forums. Turning that into a clear picture is manual and slow.

## How we use LLMs

We don't let the model "decide" facts. We use it to:

- **Extract entities** from unstructured text (names, handles, emails, IPs).
- **Suggest relationships** between entities for the analyst to confirm.
- **Summarize long threads** so analysts can triage quickly.

All outputs are tagged with confidence and linked to source snippets so everything is auditable.

## Graph visualization

We pipe extracted entities into a graph. Nodes are people, domains, IPs; edges are "mentioned together," "same email pattern," etc. The LLM helps propose edges; analysts approve or reject. Over time the graph becomes the single source of truth for a case.

## Guardrails

We never send PII to the model without redaction. We log all prompts and completions for compliance. And we keep a human in the loop for any high-stakes conclusion.

If you're in security or investigations and sitting on a lot of unstructured OSINT, LLMs can dramatically speed up the structuring phase—as long as you keep humans in control.""",
        "image": "https://images.unsplash.com/photo-1550751827-4bd374c3f58b?q=80&w=2532&auto=format&fit=crop",
        "author": "Brian Acebo",
        "author_avatar": "",
        "published_at": "2024-12-20T09:00:00Z",
        "reading_time_minutes": 7,
        "tags": ["OSINT", "Security", "LLM", "Graph"],
        "featured": False,
        "category_id": 1,
    },
    {
        "id": 3,
        "slug": "rebuilding-a-cluttered-vue-storefront-with-alpine-js",
        "title": "Rebuilding a Cluttered Vue Storefront with Alpine.js",
        "excerpt": "Instead of migrating to another heavyweight framework, we took an unconventional route: stripping back complexity with Alpine.js for a leaner, faster storefront.",
        "body": """## The Legacy Problem

We inherited a Vue.js storefront that had grown chaotic over time. What started as a simple e-commerce frontend had evolved into a tangled monolith:

- **Heavy global state** with unclear boundaries
- **Bloated third-party dependencies** and unused plugins
- **Inconsistent design tokens** and legacy components
- **Hard-to-debug hydration issues** that slowed every deploy

Onboarding new developers was painful, and even small changes felt risky. The codebase had become a liability rather than an asset.

## The Turning Point

Rather than doubling down on another full-featured framework like React or a Vue 3 migration, we took a step back and asked: *What if we didn't need all this complexity?*

Enter **Alpine.js**—a lightweight, declarative JavaScript framework that pairs perfectly with server-rendered HTML.

## Why Alpine.js

- **Lightweight:** Under 10kb gzipped—no bundle bloat
- **No hydration delay:** Works directly on server-rendered HTML
- **Simple interactivity:** Dropdowns, toggles, modals, and forms with minimal code
- **Zero build config:** Works out of the box with Liquid or any templating engine

For a Shopify storefront where most content is server-rendered anyway, Alpine was a natural fit.

## Our Approach

1. **Replaced Vue components** with native HTML enhanced by Alpine attributes (`x-data`, `x-on`, `x-show`)
2. **Leaned on Shopify Liquid templates** as the primary rendering engine—no client-side routing
3. **Handled interactive UI** (forms, modals, cart drawers) with simple directives instead of complex state management
4. **Stripped unnecessary logic**—Alpine gave us just enough without the overhead

We migrated page by page, validating performance at each step before moving on.

## Results

- **Faster FCP and TTI** across all pages
- **Lower time-to-deploy** due to simpler builds and fewer moving parts
- **Happier content team**—Liquid templates became more editable without breaking JS
- **Clean codebase** with no framework lock-in and minimal dependencies

## The Takeaway

This wasn't just a rewrite—it was a shift in mindset. We simplified the tech stack to help the business scale, and Alpine gave us a low-maintenance path to get there.

If your storefront has outgrown its framework or you're drowning in JavaScript complexity, sometimes the answer isn't a bigger hammer—it's a lighter one.""",
        "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?q=80&w=2532&auto=format&fit=crop",
        "author": "Brian Acebo",
        "author_avatar": "",
        "published_at": "2024-11-08T10:00:00Z",
        "reading_time_minutes": 6,
        "tags": ["Vue", "Alpine.js", "Shopify", "E-commerce", "Performance"],
        "featured": False,
        "category_id": 5,
    },
    {
        "id": 4,
        "slug": "a-practical-guide-to-web-performance-optimization",
        "title": "A Practical Guide to Web Performance Optimization",
        "excerpt": "Page speed isn't magic—it's about prioritizing critical resources, controlling load order, and reducing payload sizes. Here's how to approach it systematically.",
        "body": """## The Core Principle

Web performance boils down to three things:

1. **Prioritize** which resources get loaded
2. **Control** the order in which they load
3. **Reduce** the file sizes of those resources

Every optimization technique maps back to one of these. Master them and you'll ship faster sites.

---

## Understanding the Critical Rendering Path

Before optimizing, you need to understand how browsers turn code into pixels:

1. **Parse HTML** → Build the DOM tree
2. **Parse CSS** → Build the CSSOM tree
3. **Combine** DOM + CSSOM → Render tree
4. **Layout** → Compute geometry and positions
5. **Paint** → Draw pixels to the screen

The browser blocks rendering until it has enough of the DOM and CSSOM to paint something meaningful. Your job is to get critical resources to the browser as fast as possible while deferring everything else.

---

## DOM Optimizations

The DOM holds all your page content. More nodes = longer parse times and slower layout calculations.

- **Simplify your HTML**—fewer nested elements means less work for the browser
- **Adopt a mobile-first approach**—ship the smallest layout by default so mobile users don't download assets they'll never use
- **Use HTTP/2** (or HTTP/3) on your server or CDN to enable multiplexed requests

---

## CSS Optimizations

CSS is render-blocking: the browser won't paint until the CSSOM is complete. Keep it lean.

**Reduce download time:**
- Remove unused styles and split CSS into modules—load non-critical styles later
- Minify and compress your stylesheets
- Simplify selectors (`.foo` is faster than `.bar .foo`)

**Inline critical CSS:**
- Embed styles needed for above-the-fold content directly in `<head>` so users see something immediately

**Optimize fonts:**
- Use `font-display: swap` so text renders with a fallback while custom fonts load
- Preload critical fonts with `<link rel="preload" as="font">`
- Prefer WOFF2 (has built-in compression) or compressed SVG icons over icon fonts

---

## JavaScript Optimizations

JavaScript is often the biggest bottleneck—both to download and to execute.

**Reduce bundle size:**
- Keep bundles small, especially for mobile (aim for < 50–100 kB per chunk)
- Split code and lazy-load non-critical scripts
- Tree-shake and minify with your bundler

**Speed up execution:**
- Break long tasks (> 50 ms) into smaller chunks so the main thread stays responsive
- Use `defer` or `async` on non-critical scripts
- Offload heavy computation to Web Workers

**Smarter coding practices:**
- Batch DOM manipulations instead of triggering layout thrashing
- Prefer CSS animations over JS animations
- Use event delegation—one listener on a parent beats listeners on every child
- Remove event listeners when they're no longer needed

---

## Resource Hints

Tell the browser what's coming so it can start work early:

```html
<!-- Warm up the connection -->
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="dns-prefetch" href="https://cdn.example.com" />

<!-- Preload critical assets -->
<link rel="preload" href="/styles/critical.css" as="style" />
<link rel="preload" href="/scripts/main.js" as="script" />

<!-- Prefetch assets for the next navigation -->
<link rel="prefetch" href="/about" />
```

Use `preload` for assets needed on the current page; use `prefetch` for assets likely needed on the *next* page.

---

## Images & Media

Images account for over 70% of bytes on the average page.

- **Serve responsive images** with `srcset` and the `<picture>` element
- **Lazy-load** images below the fold (`loading="lazy"`)
- **Compress aggressively**—modern formats like WebP and AVIF offer better quality-to-size ratios
- **Use a CDN** with automatic image optimization

---

## Layout & Paint

After the render tree is built, the browser calculates positions (layout) and draws pixels (paint).

- **Avoid animating layout properties** like `width`, `height`, or `top`—prefer `transform` and `opacity`
- **Batch style changes** to prevent layout thrashing
- **Keep the DOM shallow**—deeper trees mean slower layout recalculations

---

## Quick Wins Checklist

- [ ] Enable HTTP/2 or HTTP/3 on your server
- [ ] Inline critical CSS; defer the rest
- [ ] Preload key fonts and hero images
- [ ] Split JS bundles and lazy-load below-the-fold code
- [ ] Compress images and serve modern formats
- [ ] Use `font-display: swap` for custom fonts
- [ ] Audit with Lighthouse and address high-impact issues first

---

## The Takeaway

Performance isn't a one-time fix—it's a discipline. Measure often, ship less JavaScript, and always ask: *Does this resource need to block the first paint?* If not, defer it.

Your users (and your Core Web Vitals scores) will thank you.""",
        "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?q=80&w=2532&auto=format&fit=crop",
        "author": "Brian Acebo",
        "author_avatar": "",
        "published_at": "2024-10-15T08:00:00Z",
        "reading_time_minutes": 12,
        "tags": ["Performance", "Web Vitals", "JavaScript", "CSS", "Optimization"],
        "featured": True,
        "category_id": 5,
    },
    {
        "id": 5,
        "slug": "the-art-of-strategic-technical-debt",
        "title": "The Art of Strategic Technical Debt",
        "excerpt": "Technical debt isn't inherently bad—it's a tool. The best engineers know when to take it on deliberately, when to pay it down, and how to communicate it to stakeholders.",
        "body": """## Debt Isn't a Dirty Word

Every codebase has technical debt. The question isn't whether you have it—it's whether you *chose* it or it happened to you.

Strategic debt is a loan against future velocity to ship something valuable today. Accidental debt is the mess that accumulates when no one's paying attention. One is a business decision; the other is a symptom of dysfunction.

---

## When to Take on Debt Deliberately

Not all shortcuts are created equal. Here's when debt makes sense:

**1. Validating an uncertain bet**

You're not sure if a feature will land. Building it "the right way" would take three sprints. Building it scrappy takes one. If you're wrong, you delete it. If you're right, you clean it up.

*Example:* Hard-coding a pricing tier to test demand before building a full billing system.

**2. Hitting a critical deadline**

A partnership launches on a fixed date. A competitor is about to ship. Sometimes the cost of delay exceeds the cost of cleanup.

*Example:* Shipping with a known edge-case bug that affects <1% of users, with monitoring in place.

**3. Learning faster**

Early in a product, you don't know what abstractions you'll need. Over-engineering now means rewriting later anyway. It's often smarter to write concrete code, ship, learn, then extract patterns.

---

## When to Pay It Down

Debt compounds. Left unchecked, it slows every future change. Pay it down when:

- **Velocity drops noticeably.** Engineers start saying "everything touches everything."
- **Onboarding takes too long.** New hires can't contribute for weeks because the codebase is incomprehensible.
- **Incidents trace back to the same areas.** That "temporary" workaround is now a recurring source of outages.
- **You're about to build on top of it.** If the next feature requires extending a fragile system, fix the foundation first.

---

## How to Communicate Debt to Stakeholders

Engineers often complain that leadership doesn't prioritize tech debt. But leadership responds to business impact, not code aesthetics.

**Frame debt in terms they care about:**

| Instead of... | Say... |
|---------------|--------|
| "The code is messy" | "This area causes 40% of our bugs" |
| "We need to refactor" | "We can cut deploy time in half" |
| "It's hard to work with" | "New features here take 3x longer" |

**Quantify the cost.** Track how much time goes to maintenance vs. new work. If 50% of engineering cycles are spent fighting fires, that's a number leadership understands.

**Propose a paydown plan.** Don't ask for a "refactor sprint." Instead, propose incremental improvements alongside feature work. "We'll clean up the auth module while building SSO."

---

## A Mental Model: The Debt Quadrant

Think of debt along two axes: **deliberate vs. accidental** and **reckless vs. prudent**.

| | Reckless | Prudent |
|---|----------|---------|
| **Deliberate** | "We don't have time for tests" | "We'll ship now and refactor before scaling" |
| **Accidental** | "What's a design pattern?" | "We didn't know better at the time" |

Aim for the **deliberate + prudent** quadrant. You're making an informed tradeoff with a plan to address it.

---

## The Takeaway

Technical debt is neither good nor bad—it's a tool. The best engineers treat it like financial debt: take it on consciously, track it visibly, and pay it down before interest crushes you.

Ship fast, but know what you're trading. And when you take on debt, write it down. Future you will be grateful.""",
        "image": "https://images.unsplash.com/photo-1554224155-8d04cb21cd6c?q=80&w=2532&auto=format&fit=crop",
        "author": "Brian Acebo",
        "author_avatar": "",
        "published_at": "2024-09-22T10:00:00Z",
        "reading_time_minutes": 8,
        "tags": ["Engineering", "Technical Debt", "Product", "Strategy", "Leadership"],
        "featured": False,
        "category_id": 1,
    },
    {
        "id": 6,
        "slug": "debugging-production-incidents-without-losing-your-mind",
        "title": "Debugging Production Incidents Without Losing Your Mind",
        "excerpt": "When production breaks at 2am, panic is your enemy. Here's a framework for staying calm, systematic, and effective under pressure.",
        "body": """## The Moment Everything Breaks

Your phone buzzes. PagerDuty. It's 2am and the dashboard is red. Users are complaining on Twitter. Your heart rate spikes.

This is the moment that separates experienced engineers from everyone else—not because they don't feel the pressure, but because they have a system for working through it.

---

## The OODA Loop for Incidents

Military pilots use **OODA: Observe, Orient, Decide, Act.** It works for incidents too.

### 1. Observe

Before you touch anything, gather information:

- **What changed recently?** Check deploy logs, feature flags, config changes
- **What's the blast radius?** All users? One region? One customer?
- **What are the symptoms?** Errors, latency, data corruption, total outage?
- **When did it start?** Correlate with deploy times or external events

Resist the urge to immediately start fixing. You can't fix what you don't understand.

### 2. Orient

Form a hypothesis. Based on what you observed:

- What subsystem is most likely responsible?
- Is this a code bug, infrastructure issue, or third-party dependency?
- Have we seen this pattern before?

Share your hypothesis with the team. Two perspectives catch blind spots.

### 3. Decide

Pick one action to test your hypothesis. The key word is *one*. Changing multiple things at once makes it impossible to know what worked.

Good first moves:
- Roll back the last deploy
- Toggle off a recent feature flag
- Increase resources if it looks like a capacity issue
- Restart a stuck service

### 4. Act (and Observe Again)

Execute your decision, then immediately check: Did it help? Metrics should respond within minutes. If not, loop back to Observe with new information.

---

## Communication During Incidents

Silence breeds anxiety. Over-communicate:

- **Acknowledge immediately.** "We're aware of the issue and investigating."
- **Post updates every 15 minutes**, even if the update is "still investigating."
- **Be specific about impact.** "Users in EU are experiencing slow load times" is better than "we're having issues."
- **Don't speculate on cause** until you're confident. Premature blame wastes time.

Designate one person as the **communications lead** so investigators can focus.

---

## The Post-Incident Review

Every incident is a learning opportunity—but only if you capture it.

**Within 48 hours**, run a blameless post-mortem:

1. **Timeline:** What happened, when, and in what order?
2. **Root cause:** What actually broke? (Use "5 Whys" to dig deeper)
3. **Contributing factors:** What made it worse or harder to detect?
4. **Action items:** Concrete improvements with owners and deadlines

The goal isn't to assign blame. It's to make the system more resilient. If a human made a mistake, ask: *Why did the system allow that mistake to cause an outage?*

---

## Building Your Incident Muscle

You can't practice incidents, but you can prepare:

- **Runbooks:** Document common failure modes and their fixes
- **Observability:** Invest in logging, metrics, and tracing *before* you need them
- **Game days:** Intentionally break things in staging to practice response
- **On-call rotations:** Spread the knowledge; don't let one person be the hero

---

## A Personal Checklist

When I get paged, I run through this mentally:

- [ ] Take a breath. Panic makes everything worse.
- [ ] Open the dashboard. What's actually broken?
- [ ] Check recent changes. Deploys, flags, configs.
- [ ] Form a hypothesis. Say it out loud.
- [ ] Pick one action. Execute. Observe.
- [ ] Communicate. Stakeholders are anxious too.
- [ ] Document as you go. You'll forget otherwise.

---

## The Takeaway

Incidents are inevitable. Chaos isn't. Build the muscle memory now—document your systems, invest in observability, and practice staying calm.

When the next 2am page comes, you won't eliminate the stress. But you'll have a system that works anyway.""",
        "image": "https://images.unsplash.com/photo-1504639725590-34d0984388bd?q=80&w=2532&auto=format&fit=crop",
        "author": "Brian Acebo",
        "author_avatar": "",
        "published_at": "2024-08-30T14:00:00Z",
        "reading_time_minutes": 9,
        "tags": ["Debugging", "Incidents", "On-Call", "Observability", "Engineering"],
        "featured": True,
        "category_id": 1,
    },
    {
        "id": 7,
        "slug": "building-apis-that-developers-actually-want-to-use",
        "title": "Building APIs That Developers Actually Want to Use",
        "excerpt": "A good API is invisible—developers can guess how it works without reading docs. Here's how to design APIs that feel intuitive, stay consistent, and evolve gracefully.",
        "body": """## The Best API Is the One You Don't Notice

You know an API is well-designed when developers can guess the endpoint, the request shape, and the response format—and be right.

Bad APIs fight you at every step. Good APIs disappear. They feel like an extension of your own code.

---

## Principles That Matter

### 1. Be Predictable

Consistency beats cleverness. If `GET /users/:id` returns a user, then `GET /orders/:id` should return an order in the same shape.

**Consistency checklist:**
- Same naming conventions everywhere (`camelCase` or `snake_case`, pick one)
- Same pagination format across all list endpoints
- Same error response structure for all failures
- Same authentication mechanism for all routes

### 2. Use HTTP Semantics Correctly

HTTP verbs have meaning. Respect them:

| Verb | Use for | Idempotent? |
|------|---------|-------------|
| GET | Read data | Yes |
| POST | Create new resources | No |
| PUT | Replace a resource entirely | Yes |
| PATCH | Partial update | Yes |
| DELETE | Remove a resource | Yes |

**Status codes matter too:**
- `200` OK (success with body)
- `201` Created (resource created)
- `204` No Content (success, no body)
- `400` Bad Request (client error, malformed input)
- `401` Unauthorized (no auth)
- `403` Forbidden (auth present, but not allowed)
- `404` Not Found
- `422` Unprocessable Entity (validation failed)
- `500` Internal Server Error (your fault, not theirs)

### 3. Design for the Consumer

Your API exists to serve developers—internal or external. Optimize for their experience.

**Return useful error messages:**

```json
// Bad
{ "error": "Invalid request" }

// Good
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Email is required",
    "field": "email"
  }
}
```

**Include what they need, exclude what they don't:**

Don't make developers call five endpoints to render one screen. But don't dump the entire database either. Find the balance.

**Support filtering, sorting, pagination from day one.** It's painful to add later.

### 4. Version Thoughtfully

APIs evolve. Breaking changes are sometimes necessary. Handle them gracefully:

- **URL versioning** (`/v1/users`) is explicit and cacheable
- **Header versioning** (`Accept: application/vnd.api+json;version=1`) is cleaner but less discoverable

Whichever you choose, commit to supporting old versions for a reasonable period. Communicate deprecations loudly and early.

---

## Common Mistakes

**Overloading POST for everything.** If you're using POST to read data, you've lost the plot.

**Inconsistent pluralization.** `/user/123` vs `/orders/456`? Pick plural or singular and stick with it.

**Exposing internal IDs.** Database auto-increment IDs leak information. Use UUIDs or opaque identifiers for public APIs.

**Ignoring rate limiting.** Without limits, one bad actor can take down your service. Return `429 Too Many Requests` and include `Retry-After` headers.

**No pagination on list endpoints.** "Get all users" works fine with 50 users. It melts your server with 50,000.

---

## Documentation Is Part of the API

An undocumented API is an unusable API.

- **OpenAPI/Swagger** specs let you auto-generate docs and client SDKs
- **Examples matter more than schemas.** Show real request/response pairs
- **Keep docs next to code.** If they live in a separate wiki, they'll rot

The best docs answer: *What can I do? How do I do it? What happens when I mess up?*

---

## A Design Checklist

Before shipping an endpoint, ask:

- [ ] Can a developer guess this endpoint exists?
- [ ] Is the naming consistent with similar endpoints?
- [ ] Are HTTP verbs and status codes used correctly?
- [ ] Do error messages help the developer fix the problem?
- [ ] Is there pagination for list endpoints?
- [ ] Is it documented with examples?
- [ ] Is there a versioning strategy?

---

## The Takeaway

APIs are contracts. Every decision you make—naming, structure, error handling—becomes a promise to every developer who integrates with you.

Design with empathy. Be consistent. Document relentlessly.

Build the API you'd want to use yourself.""",
        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?q=80&w=2532&auto=format&fit=crop",
        "author": "Brian Acebo",
        "author_avatar": "",
        "published_at": "2024-08-10T09:00:00Z",
        "reading_time_minutes": 10,
        "tags": ["API Design", "REST", "Backend", "Developer Experience", "Architecture"],
        "featured": False,
        "category_id": 1,
    },
]

notifications = [
    {
        "id": 1,
        "title": "New Project Added - Paperboat CRM",
        "description": "Checking out the new project added to the portfolio",
        "createdAt": "2026-02-02T20:00:00Z",
        "read": False,
        "source_id": 1,
        "source_slug": "paperboat-crm",
        "source_type": "project",
        "source_image": portfolio_projects[0]["image"]
    },
    {
        "id": 2,
        "title": "Open Source Intelligence Assistant",
        "description": "Checking out the new project added to the portfolio",
        "createdAt": "2026-02-02T16:00:00Z",
        "read": False,
        "source_id": 2,
        "source_slug": "open-source-intelligence-assistant",
        "source_type": "project",
        "source_image": portfolio_projects[1]["image"]
    },
    {
        "id": 3,
        "title": "Read Blog Post - Building AI Voice Dialers with GPT-4 and DeepGram",
        "description": "Checking out the new blog post added to the blog",
        "createdAt": "2026-02-02T15:00:00Z",
        "read": False,
        "source_id": 7,
        "source_slug": "building-ai-voice-dialers-with-gpt-and-deepgram",
        "source_type": "blog_post",
        "source_image": blog_posts[6]["image"]
    },
    {
        "id": 4,
        "title": "Read Blog Post - Building APIs That Developers Actually Want to Use",
        "description": "Read the blog post details for Building APIs That Developers Actually Want to Use",
        "createdAt": "2026-02-02T10:00:00Z",
        "read": False,
        "source_id": 1,
        "source_slug": "building-apis-that-developers-actually-want-to-use",
        "source_type": "blog_post",
        "source_image": blog_posts[1]["image"]
    },
    {
        "id": 5,
        "title": "Viewed Project - Nascent",
        "description": "View the project details for Nascent",
        "createdAt": "2026-02-02T10:00:00Z",
        "read": False,
        "source_id": 4,
        "source_slug": "nascent",
        "source_type": "project",
        "source_image": portfolio_projects[2]["image"],
    }
]

profiles = [
    {
        "id": 1,
        "name": "Brian Acebo",
        "email": "brian@acebo.com",
        "avatar": "https://robohash.org/XN6.png?set=set1",
        "created_at": "2026-02-02T20:00:00Z",
        "updated_at": "2026-02-02T20:00:00Z",
    },
    {
        "id": 2,
        "name": "John Doe",
        "email": "john@doe.com",
        "avatar": "https://robohash.org/D62.png?set=set1",
        "created_at": "2026-02-02T20:00:00Z",
        "updated_at": "2026-02-02T20:00:00Z",
    },
    {
        "id": 3,
        "name": "Jane Doe",
        "email": "jane@doe.com",
        "avatar": "https://robohash.org/Z8Z.png?set=set1",
        "created_at": "2026-02-02T20:00:00Z",
        "updated_at": "2026-02-02T20:00:00Z",
    },
]